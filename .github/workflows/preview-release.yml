name: Release Preview

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  preview:
    name: Preview Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install dependencies
        run: npm install -g pnpm && pnpm install --frozen-lockfile

      - name: Semantic Release Dry Run
        id: semantic
        env:
          # Pass the token, but we need to hide the PR context from semantic-release
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Run semantic-release in dry-run mode
          # We unset GITHUB_ variables so semantic-release doesn't think it's in a PR workflow
          # and refuses to run. We want it to treat the current checkout as the 'dev' branch.
          
          env -u GITHUB_EVENT_NAME -u GITHUB_REF -u GITHUB_HEAD_REF -u GITHUB_SHA \
            npx semantic-release --dry-run --no-ci --branches ${{ github.head_ref }} > release-output.txt 2>&1 || true
          
          # Cat the output for debugging
          cat release-output.txt
          
          # Extract version
          VERSION=$(grep "The next release version is" release-output.txt | sed -E 's/.*The next release version is (.*)/\1/')
          
          if [ -z "$VERSION" ]; then
            echo "No release triggered."
            echo "new_release_published=false" >> $GITHUB_OUTPUT
          else
            echo "Found next version: $VERSION"
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
            
            # Extract notes (this is trickier from stdout, but let's try a simple approach first)
            # Ideally semantic-release plugins output this, but for now we'll just link to the release.
            # actually, we can try to grab the release notes if they are printed.
            # A better way is to rely on the fact that we know the version.
          fi

      - name: Generate Release Notes
        if: steps.semantic.outputs.new_release_published == 'true'
        id: notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use the API to generate release notes for the calculated tag
          # This ensures we get the exact same formatting as GitHub Releases
          NOTES=$(gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /repos/${{ github.repository }}/releases/generate-notes \
            -f tag_name="v${{ steps.semantic.outputs.new_release_version }}" \
            -f target_commitish="${{ github.head_ref }}" \
            --jq '.body')
            
          # Escape newlines for GITHUB_OUTPUT
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "release_notes<<$EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "$EOF" >> $GITHUB_OUTPUT

      - name: Update PR
        if: steps.semantic.outputs.new_release_published == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ steps.semantic.outputs.new_release_version }}
          NOTES: ${{ steps.notes.outputs.release_notes }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          gh pr edit "$PR_NUMBER" \
            --title "chore(release): v$VERSION" \
            --body "### ðŸš€ Release Preview: v$VERSION
          
          _This description is automatically generated based on the commits in this Pull Request._
          
          $NOTES"
